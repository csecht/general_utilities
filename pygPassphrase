#!/usr/bin/env python3

"""
Inspired by and based on code from @codehub.py via Instagram.
Not usable on Windows because of no way(?) to read the Dictionary.
"""
import os
import random
import re
import sys
from string import digits, punctuation, ascii_letters, ascii_uppercase
from pathlib import Path

try:
    import tkinter as tk
    # import tkinter.ttk as ttk
except (ImportError, ModuleNotFoundError) as error:
    print('GUI requires tkinter, which is included with Python 3.7 and higher')
    print('Install 3.7+ or re-install Python and include Tk/Tcl.')
    print(f'See also: https://tkdocs.com/tutorial/install.html \n{error}')

PROGRAM_VER = '0.2.0'
STUBRESULT = 'Result can be copied and pasted'
SYMBOLS = "~!@#$%^&*_-"
MY_OS = sys.platform[:3]
# MY_OS = 'win' # TESTING
USE_EFF = True

# TODO: Should make this a method and provide Messagebox notices.
sysdict_path = Path('/pusr/share/dict/words')
effdict_path = Path('eff_large_wordlist.txt')
# Already evaluated presence of Windows eff file in if __name__, now need to
#  evaluate whether both word lists are available to Linux and MacOS.
if MY_OS == 'win':
    SYS_DICTIONARY = 'Null'
    EFF_DICTIONARY = Path(effdict_path).read_text()

if MY_OS in 'lin, dar':
    # if os.path.isfile('/usr/share/dict/words'):
    if Path.is_file(sysdict_path):
        SYS_DICTIONARY = Path(sysdict_path).read_text()
    elif Path.is_file(sysdict_path) is False:
        print('\n*** NOTICE: The system dictionary cannot be found;\n'
              'EFF word list will be used.\n')
        SYS_DICTIONARY = 'Null'
        # ^^^ This sets a flag in make_pass() to bypass system dict.
# TODO: Notify user that the eff check button does nothing.
    # if os.path.isfile('eff_large_wordlist.txt'):
    if Path.is_file(effdict_path):
        EFF_DICTIONARY = Path(effdict_path).read_text()
    elif Path.is_file(effdict_path) is False:
        USE_EFF = False
        print('The eff_large_wordlist.txt is not in the working directory.\n'
              'That file can be downloaded from:\n'
              'https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt\n'
              'This session will use only the system dictionary.\n')


class Generator:
    """
    Makes a GUI window for user to specify length of passwords and passphrases.
    """
    def __init__(self, master):
        """Window layout and default values are set up here.
        """
        self.master = master
        self.master.bind("<Escape>", lambda q: quitgui())
        self.master.bind("<Control-q>", lambda q: quitgui())

        # main window background color, also used for some labels.
        self.master_bg = 'SkyBlue4'
        self.master_fg = 'LightCyan2'  # foreground for user entry labels
        self.frame_bg = 'grey40'  # background for data labels and frame
        self.frame_fg = 'grey90'
        self.passstub_fg = 'grey60'
        self.pass_fg = 'brown4'
        self.pass_bg = 'khaki2'

        # Variables used in window_setup(), in order of appearance:
        #  Don't make an EFF checkbutton in Windows b/c EFF words are default.
        if MY_OS in 'lin, dar':
            self.eff = tk.BooleanVar()
            self.eff_chk = tk.Checkbutton()
        self.numwords_label = tk.Label()
        self.numwords_entry = tk.Entry()
        self.numchars_label = tk.Label()
        self.numchars_entry = tk.Entry()
        self.generate_btn = tk.Button()
        self.quit_btn = tk.Button()
        self.result_frame = tk.Frame(self.master)
        self.length_label = tk.Label(self.result_frame)
        self.passphrase_label = tk.Label(self.result_frame)
        self.any_describe = tk.Label(self.result_frame)
        self.any_lc_describe = tk.Label(self.result_frame)
        self.select_describe = tk.Label(self.result_frame)
        self.length_any = tk.IntVar()
        self.length_lc = tk.IntVar()
        self.length_select = tk.IntVar()
        self.length_any_label = tk.Label(self.result_frame)
        self.length_lc_label = tk.Label(self.result_frame)
        self.length_select_label = tk.Label(self.result_frame)
        self.phrase_any = tk.StringVar()
        self.phrase_lc = tk.StringVar()
        self.phrase_select = tk.StringVar()
        self.phrase_any_display = tk.Entry(self.result_frame,
                                           textvariable=self.phrase_any)
        self.phrase_lc_display = tk.Entry(self.result_frame,
                                          textvariable=self.phrase_lc)
        self.phrase_sel_display = tk.Entry(self.result_frame,
                                           textvariable=self.phrase_select)
        self.pw_label = tk.Label(self.result_frame)
        self.pw_any_describe = tk.Label(self.result_frame)
        self.pw_select_describe = tk.Label(self.result_frame)
        self.pw_any = tk.StringVar()
        self.pw_select = tk.StringVar()
        self.pw_any_display = tk.Entry(self.result_frame,
                                       textvariable=self.pw_any,)
        self.pw_select_display = tk.Entry(self.result_frame,
                                          textvariable=self.pw_select)

        # Variables used in make_pass():
        self.word_list = []
        self.uniq_words = []
        self.trim_words = []
        self.allwords = None
        self.somewords = None
        self.effwords = None

        self.window_setup()

    def window_setup(self):
        """
        Layout the main window and assign initial values to labels.

        :return: A pretty interactive window.
        """
        self.master.configure(bg=self.master_bg)

        # creating a menu instance
        menu = tk.Menu(self.master)
        self.master.config(menu=menu)

        # Add pull-down menus
        file = tk.Menu(menu, tearoff=0)
        menu.add_cascade(label="File", menu=file)
        file.add_command(label="Quit", command=quitgui, accelerator="Ctrl+Q")

        help_menu = tk.Menu(menu, tearoff=0)
        menu.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Explanation", command=explain)
        help_menu.add_command(label="About", command=about)

        # Set up user entry and control:
        if MY_OS in 'lin, dar':
            self.eff_chk.config(text='Use EFF word list ',
                                variable=self.eff,
                                fg=self.master_fg, bg=self.master_bg,
                                activebackground='grey80',
                                selectcolor=self.frame_bg)
            self.eff_chk.grid(column=2, row=0, pady=5, sticky=tk.W)
        if USE_EFF is False:
            self.eff_chk.config(state='disabled')

        self.numwords_label.config(text='Enter # words for passphrase',
                                   fg=self.master_fg, bg=self.master_bg)
        self.numwords_entry.config(width=2)
        self.numwords_entry.insert(0, '5')
        self.numwords_entry.focus()
        self.numchars_label.config(text='Enter # characters for password',
                                   fg=self.master_fg, bg=self.master_bg)
        self.numchars_entry.config(width=3)
        self.numchars_entry.insert(0, 0)
        self.generate_btn.config(text='Generate!', command=self.make_pass,
                                 activebackground='PaleGreen3',
                                 fg='grey20', bg='grey80')
        self.quit_btn.config(text='Quit', command=quitgui,
                             activebackground='red3',
                             fg='grey20', bg='grey80')

        # self.eff_chk.grid(column=2, row=0, pady=5, sticky=tk.W)
        self.numwords_label.grid(column=0, row=0, padx=5, pady=(5, 0),
                                 sticky=tk.E)
        self.numwords_entry.grid(column=1, row=0, pady=(5, 0), sticky=tk.W)
        self.numchars_label.grid(column=0, row=1, padx=5, pady=3, sticky=tk.E)
        self.numchars_entry.grid(column=1, row=1, sticky=tk.W)
        self.generate_btn.grid(  column=2, row=1, sticky=tk.W)
        self.quit_btn.grid(      column=3, row=1, sticky=tk.W)

        # Set up frame for results:
        self.result_frame.config(borderwidth=3, relief='sunken',
                                 background=self.frame_bg)
        self.result_frame.grid(column=0, row=2, columnspan=4, padx=5, pady=5)

        # Passphrase results section:
        # https://anzeljg.github.io/rin2/book2/2405/docs/tkinter/ttk-style-layer.html
        # This style statement for background of ttk.Labels does not work on MacOS
        # rstyle = ttk.Style()
        # rstyle.configure('TLabel', foreground=self.frame_fg, bg=self.frame_bg)
        self.length_label.config(    text='Length',
                                     fg=self.frame_fg, bg=self.frame_bg)
        self.passphrase_label.config(text='Passphrases',
                                     fg=self.frame_fg, bg=self.frame_bg)
        self.length_label.grid(    column=1, row=2, padx=5, sticky=tk.EW)
        self.passphrase_label.grid(column=2, row=2, padx=5, sticky=tk.W)

        self.any_describe.config(   text="Any words",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.any_lc_describe.config(text="Lower case, plus 3 symbols",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.select_describe.config(text="Words of 3 to 8 letters",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.any_describe.grid(   column=0, row=3, sticky=tk.E)
        self.any_lc_describe.grid(column=0, row=4, sticky=tk.E)
        self.select_describe.grid(column=0, row=5, sticky=tk.E)

        self.length_any.set(0)
        self.length_lc.set(0)
        self.length_select.set(0)
        self.length_any_label.config(   textvariable=self.length_any,
                                        width=3)
        self.length_lc_label.config(    textvariable=self.length_lc,
                                        width=3)
        self.length_select_label.config(textvariable=self.length_select,
                                        width=3)
        self.length_any_label.grid(   column=1, row=3)
        self.length_lc_label.grid(    column=1, row=4)
        self.length_select_label.grid(column=1, row=5)

        self.phrase_any.set(STUBRESULT)
        self.phrase_lc.set(STUBRESULT)
        self.phrase_select.set(STUBRESULT)
        self.phrase_any_display.config(width=50, font='TkFixedFont',
                                       fg=self.passstub_fg, bg=self.pass_bg)
        self.phrase_lc_display.config(width=50, font='TkFixedFont',
                                      fg=self.passstub_fg, bg=self.pass_bg)
        self.phrase_sel_display.config(width=50, font='TkFixedFont',
                                       fg=self.passstub_fg, bg=self.pass_bg)
        self.phrase_any_display.grid(column=2, row=3, columnspan=2,
                                     ipadx=5, padx=5, pady=3, sticky=tk.EW)
        self.phrase_lc_display.grid(column=2, row=4, columnspan=2,
                                    ipadx=5, padx=5, pady=3, sticky=tk.EW)
        self.phrase_sel_display.grid(column=2, row=5, columnspan=2,
                                     ipadx=5, padx=5, pady=3, sticky=tk.EW)

        # Password results section:
        self.pw_label.config(text='Passwords',
                             fg=self.frame_fg, bg=self.frame_bg)
        self.pw_label.grid(column=2, row=6, padx=5, sticky=tk.W)

        self.pw_any_describe.config(text="Any characters",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.pw_select_describe.config(text="More likely usable characters ",
                                       fg=self.frame_fg, bg=self.frame_bg)
        self.pw_any.set(STUBRESULT)
        self.pw_select.set(STUBRESULT)
        self.pw_any_display.config(width=50, font='TkFixedFont',
                                   fg=self.passstub_fg, bg=self.pass_bg)
        self.pw_select_display.config(width=50, font='TkFixedFont',
                                      fg=self.passstub_fg, bg=self.pass_bg)
        self.pw_any_describe.grid(   column=0, row=7,
                                     padx=5, sticky=tk.E)
        self.pw_select_describe.grid(column=0, row=8,
                                     padx=5, sticky=tk.E)
        self.pw_any_display.grid(    column=2, row=7, columnspan=2, ipadx=5,
                                     padx=5, pady=(6, 3), sticky=tk.EW)
        self.pw_select_display.grid( column=2, row=8, columnspan=2, ipadx=5,
                                     padx=5, pady=(3, 6), sticky=tk.EW)

    def make_pass(self):
        """Generate various forms of passphrases and passwords.
        """

        secure_random = random.SystemRandom()

        # sys_dictionary = Path('/usr/share/dict/words').read_text()
        word_list = SYS_DICTIONARY.split()
        # Need to remove words having the possessive form.
        uniq_words = [word for word in word_list if re.search(r"'s",word) is None]
        trim_words = [word for word in uniq_words if 8 >= len(word) >= 3]
        eff_list = EFF_DICTIONARY.split()
        eff_words = [word for word in eff_list if word.isalpha()]

        caps = ascii_uppercase
        string1 = ascii_letters + digits + punctuation
        string2 = ascii_letters + digits + SYMBOLS

        self.allwords = "".join(secure_random.choice(uniq_words) for
                           _ in range(int(self.numwords_entry.get())))
        self.somewords = "".join(secure_random.choice(trim_words) for
                            _ in range(int(self.numwords_entry.get())))
        self.effwords = "".join(secure_random.choice(eff_words) for
                           _ in range(int(self.numwords_entry.get())))
        addsymbol = "".join(secure_random.choice(SYMBOLS) for _ in range(1))
        addCap = "".join(secure_random.choice(caps) for _ in range(1))
        addnum = "".join(secure_random.choice(digits) for _ in range(1))

        # 1st condition evaluates eff checkbutton on, 2nd if no sys dict found.
        # 3rd, EFF is forced in linux, Mac, so disable eff checkbutton.
        # TODO: Think of a better flow of logic and structure. Too confusing.
        # TODO: Also need to notify user (early on) when options are limited.
        if MY_OS in 'lin, dar' and self.eff.get() is True:
            self.allwords = self.effwords
            self.somewords = self.effwords
        elif MY_OS == 'win' or SYS_DICTIONARY == 'Null':
            self.allwords = self.effwords
            self.somewords = self.effwords
            if MY_OS in 'lin, dar':
                self.eff_chk.config(state='disabled')

        passphrase1 = self.allwords.lower() + addsymbol + addnum + addCap
        passphrase2 = self.somewords.lower() + addsymbol + addnum + addCap
        password1 = "".join(secure_random.choice(string1) for
                            _ in range(int(self.numchars_entry.get())))
        password2 = "".join(secure_random.choice(string2) for
                            _ in range(int(self.numchars_entry.get())))

        # display.config width will adjust width of results entry widgets to
        # the longest result string.
        self.phrase_any_display.config(width=len(passphrase1))
        self.pw_any_display.config(width=len(password1))
        self.pw_select_display.config(width=len(password2))

        self.phrase_any.set(self.allwords)
        self.phrase_lc.set(passphrase1)
        self.phrase_select.set(passphrase2)
        self.length_any.set(len(self.allwords))
        self.length_lc.set(len(passphrase1))
        self.length_select.set(len(passphrase2))
        self.pw_any.set(password1)
        self.pw_select.set(password2)
        # Change font colors of the results from self.passstub_fg
        self.phrase_any_display.config(fg=self.pass_fg)
        self.phrase_lc_display.config(fg=self.pass_fg)
        self.phrase_sel_display.config(fg=self.pass_fg)
        self.pw_any_display.config(fg=self.pass_fg)
        self.pw_select_display.config(fg=self.pass_fg)


def about() -> None:
    """
    Basic information for count-tasks; called from GUI Help menu.

    :return: Information window.
    """
    # msg separators use em dashes.
    boilerplate = ("""
pygPassphrase privately generates passphrases and passwords.
Download the most recent version from: 
https://github.com/csecht/general_utilities

————————————————————————————————————————————————————————————————————
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.\n
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.\n
You should have received a copy of the GNU General Public License
along with this program. If not, see https://www.gnu.org/licenses/
————————————————————————————————————————————————————————————————————\n
            Author:     cecht
            Copyright:  Copyright (C) 2021 C. Echt
            Development Status: 4 - Beta
            Version:    """)

    num_lines = boilerplate.count('\n')
    aboutwin = tk.Toplevel()
    # aboutwin.minsize(570, 460)
    aboutwin.title('About count-tasks')
    colour = ['SkyBlue4', 'DarkSeaGreen4', 'DarkGoldenrod4', 'DarkOrange4',
              'grey40', 'blue4', 'navy', 'DeepSkyBlue4', 'dark slate grey',
              'dark olive green', 'grey2', 'grey25', 'DodgerBlue4',
              'DarkOrchid4']
    bkg = random.choice(colour)
    abouttxt = tk.Text(aboutwin, width=72, height=num_lines + 2,
                       background=bkg, foreground='grey98',
                       relief='groove', borderwidth=5, padx=5)
    abouttxt.insert('1.0', boilerplate + PROGRAM_VER)
    # Center text preceding the Author, etc. details.
    abouttxt.tag_add('text1', '1.0', float(num_lines - 5))
    abouttxt.tag_configure('text1', justify='center')
    abouttxt.pack()


def explain() -> None:
    """Provide information about number of words used to create passphrases
    """
    # This duplicates statements from make_pass(). So include as class method?
    word_list = SYS_DICTIONARY.split()
    uniq_words = [word for word in word_list if re.search(r"'s", word) is None]
    trim_words = [word for word in uniq_words if 8 >= len(word) >= 3]
    eff_list = EFF_DICTIONARY.split()
    eff_words = [word for word in eff_list if word.isalpha()]

    info = (
        'A passphrase is a random string of words that can be more secure and \n'
        'easier to remember than a shorter or complicated password.\n'
        "For more information on passphrases, see EFF's discussion, for example,\n"
        'of diceware and wordlist selection at:\n\n'
        'https://www.eff.org/deeplinks/2016/07/new-wordlists-random-passphrases\n'
        'This program has an option to use the EFF long wordlist.\n'
        'Windows systems will always use the EFF wordlist without another option.\n\n'
        f'In the system dictionary used to create general passphrases:\n'
        f"    There are {len(word_list)} words in the entire dictionary.\n"
        f"    There are {len(uniq_words)} unique words (excludes "
        "possessive forms of nouns (English dictionary)\n"
        f"    There are {len(trim_words)} unique words of 3 to 8 letters.\n"
        "Passphrases may include proper names and diacritics found in the "
        "dictionary.\n"
        "The extra symbols added to passphrases and those more likely "
        f"usable in passwords are:\n{SYMBOLS}\n\n"
        'The word list from Electronic Frontier Foundation (EFF),\n'
        'https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt, '
        'does not contain \nproper names or diacritics and its words are '
        'generally shorter and easier to spell.\n'
        'While that official list contains 7776 selected words, only '
        f'{len(eff_words)} are used here,\nexcluding four hyphenated words.'
        )

    infowin = tk.Toplevel()
    # infowin.minsize(750, 250)
    infowin.title('A little about passphrases')
    num_lines = info.count('\n')
    infotxt = tk.Text(infowin, width=90, height=num_lines+2,
                      background='SkyBlue4', foreground='grey98',
                      relief='groove', borderwidth=5, padx=5)
    infotxt.insert('1.0', info)
    # Center text preceding the Author, etc. details.
    # infotxt.tag_add('text1', '1.0', float(num_lines - 5))
    # infotxt.tag_configure('text1', justify='center')
    infotxt.pack()


def quitgui() -> None:
    """Safe and informative exit from the program.
    """
    print(f'\n  *** User has quit {__file__}. Exiting...\n')
    root.destroy()
    sys.exit(0)


if __name__ == "__main__":
    os.chdir(os.path.dirname(os.path.realpath(__file__)))
    MSG = ('Cannot locate either the system dictionary and EFF word list. \n'
           'At a minimum, the file eff_large_wordlist.txt should be in '
           'the working directory.\nThat file can be downloaded from:\n'
           'https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt\n'
           'Exiting now...')
    if MY_OS in 'lin, dar':
        if not os.path.isfile('/usr/share/dict/words') and not os.path.isfile(
                'eff_large_wordlist.txt'):
            print(MSG)
            sys.exit(1)
    elif MY_OS == 'win' and not os.path.isfile('eff_large_wordlist.txt'):
        print(MSG)
        sys.exit(1)
    root = tk.Tk()
    root.title("Passphrase Generator")
    # root.resizable(False, False)
    Generator(root)
    root.mainloop()
